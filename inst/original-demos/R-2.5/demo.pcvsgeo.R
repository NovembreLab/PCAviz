# This script generates a scatterplot comparing geographic (map)
# distances against PC-based Euclidean distances. Compare the plot
# generated by this script against Figure 5 in the supplement of the
# "Genes mirror geography" paper.
#
# This script has been tested in R version 2.5.1, with sp package
# version 0.9-28. Note: since the map rendering can be very slow, I
# recommend using ThinLinc instead of X11 forwarding to display
# graphics.
#
library(sp)
source("../functions.R")

# SCRIPT PARAMETERS
# -----------------
sx  <- 1  # Scaling factor for PC1.
sy  <- 1  # Scaling factor for PC2.
phi <- 0  # Rotation angle

# Load the PCA results.
PCA <- read.table(paste("../../original-files/data/POPRES_08_24_01.",
                        "EuroThinFinal.LD_0.8.exLD.out0-PCA.eigs",sep=""),
                  col.names = c("FamID","ID",paste("PC",1:20,sep=""),"flag"))

# Load the POPRES population and geographic annotations.
ddata <- read.table("../../original-files/data/PCA.txt",sep = "\t",
                    header = TRUE,stringsAsFactors = FALSE)

# Fix up some of the country-of-origin annotations for the plots.
poslabel <- fix.country.names(ddata$plabels)

# Get the abbreviated population labels assigned to each of the POPRES
# samples.
abbrvlabel <- abbrvlabels(ddata$plabels)

# Retrieve the geographic co-ordinate data for the countries.
load("../../original-files/data/world_countries.rda")
xvals <- coordinates(world_countries)[match(toupper(levels(factor(poslabel))),
                                            world_countries$names),1]
yvals <- coordinates(world_countries)[match(toupper(levels(factor(poslabel))),
                                            world_countries$names),2]
posdata            <- data.frame(Long = xvals,Lat = yvals)
row.names(posdata) <- levels(factor(poslabel))

# Get the label assigned to each of the POPRES samples.
rows    <- match(PCA$ID,ddata$ID)
alabels <- abbrvlabel[rows]
plabels <- poslabel[rows]

# Compute the median projection onto PCs 1 and 2 (after applying the 
# rotation).
PC1median <- tapply(rotPC1(phi,sx,sy),alabels,median)
PC2median <- tapply(rotPC2(phi,sx,sy),alabels,median)

# Get the country-level geographic co-ordinates.
r    <- tapply(plabels,factor(alabels),function(x) return(x[1]))
xleg <- posdata[r,1]
yleg <- posdata[r,2]    

# Compute Euclidean distance according to projection onto PCs 1 and 2
# (note that this result is not used).
PCdistMatrix <- apply(cbind(PC1median,PC2median),1,
                      function(x) spDistsN1(cbind(PC1median,PC2median),x,
                                            longlat = FALSE))

# Compute a weighted Euclidean distance.
weighteddist <- function (M, z, l1, l2)
  apply(M,1,function(x) sqrt(l1*(x[1] - z[1])^2 + l2*(x[2] - z[2])^2))
PCdistMatrix <- apply(cbind(PC1median,PC2median),1,
                      function(x) weighteddist(cbind(PC1median,PC2median),x,
                                               l1 = 1/4.09,l2 = 1/2.04))

# Compute geographic distances between all pairs of countries.
geodistMatrix <-
  apply(cbind(xleg,yleg),1,function(x) spDistsN1(cbind(xleg,yleg),x,
                                                 longlat = TRUE))
rownames(geodistMatrix) <- rownames(PCdistMatrix)
colnames(geodistMatrix) <- colnames(PCdistMatrix)

rawlabels      <- expand.grid(levels(factor(alabels)),levels(factor(alabels)))
pwlabelsMatrix <- paste(rawlabels$Var1,rawlabels$Var2)
n              <- length(levels(factor(alabels)))
ids            <- apply(combn(1:n,2),2,function(x) x[1] + n*(x[2] - 1))

# Set up new data structures for the plots.
geodist  <- geodistMatrix[ids]
PCdist   <- PCdistMatrix[ids]
pwlabels <- pwlabelsMatrix[ids]

# Remove all country pairs in which geographic distance is > 4,000 km.
geodistMatrix[geodistMatrix > 4000] <- NA
i        <- !is.na(geodist)
geodist  <- geodist[i]
PCdist   <- PCdist[i]
pwlabels <- pwlabels[i]

# Estimate the linear relationship between geographic distance and
# PC-based distance.
lPC      <- lm(PCdist ~ geodist)
residsPC <- abs(lPC$residuals)
outlier  <- residsPC > quantile(residsPC,0.975)

# Draw the scatterplot comparing the geographic distances against the
# PC-based Euclidean distances, highlighting outliers in the trend.
plot(geodist,PCdist,type = "n",xlab = "Geographic distance (km)",
     ylab = "Euclidean distance in PC1-PC2 space")
points(geodist[!outlier],PCdist[!outlier],pch = 16,cex = 0.8,
       col = "royalblue")
points(geodist[outlier],PCdist[outlier],pch = 16,
       cex = 0.8,col = "magenta")
text(geodist[outlier],PCdist[outlier],pwlabels[outlier],
     cex = 0.75,col = "magenta",pos = 4)

# Visualize the linear trends in the plot.
alpha <- 0.025
abline(lPC)
abline(lPC$coefficients[1] + quantile(residsPC,1 - alpha),
       lPC$coefficients[2],lty = 2)
abline(lPC$coefficients[1] - quantile(residsPC,1 - alpha),
       lPC$coefficients[2],lty = 2)
