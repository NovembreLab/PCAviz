# This script generates a scatterplot comparing geographic (map)
# distances against PC-based Euclidean distances. Compare the plot
# generated by this script against Figure 5 in the supplement of the
# "Genes mirror geography" paper.
#
# When create.plotly = TRUE, this script also creates an HTML file
# containing an interactive plot generated using the plotly library.
#
# This script has been tested in R version 3.3.2, with sp package
# version 1.2-4, rworldmap package version 1.3-6, and the proj library
# version 4.9 (on midway2, type "module load proj/4.9"). Also, note
# that since the map rendering can be very slow, I recommend using
# ThinLinc instead of X11 forwarding to display graphics.
library(sp)
library(rworldmap)
library(ggplot2)
library(htmlwidgets)
library(plotly)
source("../functions.R")

# SCRIPT PARAMETERS
# -----------------
sx  <- 1  # Scaling factor for PC1.
sy  <- 1  # Scaling factor for PC2.
phi <- 0  # Rotation angle
create.plotly <- TRUE

# Load the PCA results.
PCA <- read.table(paste("../../original-files/data/POPRES_08_24_01.",
                        "EuroThinFinal.LD_0.8.exLD.out0-PCA.eigs",sep=""),
                  col.names = c("FamID","ID",paste("PC",1:20,sep=""),"flag"))

# Load the POPRES population and geographic annotations.
ddata <- read.table("../../original-files/data/PCA.txt",sep = "\t",
                    header = TRUE,stringsAsFactors = FALSE)

ddata$alabels[grep("UK",ddata$alabels)]="GB"
ddata$alabels[grep("YG",ddata$alabels)]="RS"
ddata$alabels[grep("Sct",ddata$alabels)]="GB"
ddata$alabels[grep("KS",ddata$alabels)]="RS"

# Fix up some of the country-of-origin annotations for the plots.
poslabel <- fix.country.names2(ddata$plabels)

# Get the abbreviated population labels assigned to each of the POPRES
# samples.
abbrvlabel <- abbrvlabels2(ddata$plabels)

# Retrieve the geographic co-ordinate data for the countries.
world_countries <-
  joinCountryData2Map(ddata,joinCode = "ISO2",nameJoinColumn = "alabels")
xvals <- coordinates(world_countries)[match(levels(factor(poslabel)),
                                            world_countries$NAME),1]
yvals <- coordinates(world_countries)[match(levels(factor(poslabel)),
                                            world_countries$NAME),2]
posdata            <- data.frame(Long = xvals,Lat = yvals)
row.names(posdata) <- levels(factor(poslabel))

# Get the label assigned to each of the POPRES samples.
rows    <- match(PCA$ID,ddata$ID)
alabels <- abbrvlabel[rows]
plabels <- poslabel[rows]

# Compute the median projection onto PCs 1 and 2 (after applying the 
# rotation).
PC1median <- tapply(rotPC1(phi,sx,sy),alabels,median)
PC2median <- tapply(rotPC2(phi,sx,sy),alabels,median)

# Get the country-level geographic co-ordinates.
r    <- tapply(plabels,factor(alabels),function(x) return(x[1]))
xleg <- posdata[r,1]
yleg <- posdata[r,2]    

# Compute Euclidean distance according to projection onto PCs 1 and 2
# (note that this result is not used).
PCdistMatrix <- apply(cbind(PC1median,PC2median),1,
                      function(x) spDistsN1(cbind(PC1median,PC2median),x,
                                            longlat = FALSE))

# Compute a weighted Euclidean distance.
weighteddist <- function (M, z, l1, l2)
  apply(M,1,function(x) sqrt(l1*(x[1] - z[1])^2 + l2*(x[2] - z[2])^2))
PCdistMatrix <- apply(cbind(PC1median,PC2median),1,
                      function(x) weighteddist(cbind(PC1median,PC2median),x,
                                               l1 = 1/4.09,l2 = 1/2.04))

# Compute geographic distances between all pairs of countries.
geodistMatrix <-
  apply(cbind(xleg,yleg),1,function(x) spDistsN1(cbind(xleg,yleg),x,
                                                 longlat = TRUE))
rownames(geodistMatrix) <- rownames(PCdistMatrix)
colnames(geodistMatrix) <- colnames(PCdistMatrix)

rawlabels      <- expand.grid(levels(factor(alabels)),levels(factor(alabels)))
pwlabelsMatrix <- paste(rawlabels$Var1,rawlabels$Var2)
n              <- length(levels(factor(alabels)))
ids            <- apply(combn(1:n,2),2,function(x) x[1] + n*(x[2] - 1))

# Set up new data structures for the plots.
geodist  <- geodistMatrix[ids]
PCdist   <- PCdistMatrix[ids]
pwlabels <- pwlabelsMatrix[ids]

# Remove all country pairs in which geographic distance is > 4,000 km.
geodistMatrix[geodistMatrix > 4000] <- NA
i        <- !is.na(geodist)
geodist  <- geodist[i]
PCdist   <- PCdist[i]
pwlabels <- pwlabels[i]

# Estimate the linear relationship between geographic distance and
# PC-based distance.
lPC      <- lm(PCdist ~ geodist)
residsPC <- abs(lPC$residuals)
outlier  <- residsPC > quantile(residsPC,0.975)

# Draw the scatterplot comparing the geographic distances against the
# PC-based Euclidean distances, highlighting outliers in the trend.
plot(geodist,PCdist,type = "n",xlab = "Geographic distance (km)",
     ylab = "Euclidean distance in PC1-PC2 space")
points(geodist[!outlier],PCdist[!outlier],pch = 16,cex = 0.8,
       col = "royalblue")
points(geodist[outlier],PCdist[outlier],pch = 16,
       cex = 0.8,col = "magenta")
text(geodist[outlier],PCdist[outlier],pwlabels[outlier],
     cex = 0.75,col = "magenta",pos = 4)

# Visualize the linear trends in the plot.
alpha <- 0.025
abline(lPC)
abline(lPC$coefficients[1] + quantile(residsPC,1 - alpha),
       lPC$coefficients[2],lty = 2)
abline(lPC$coefficients[1] - quantile(residsPC,1 - alpha),
       lPC$coefficients[2],lty = 2)

# If requested, create the interactive plot using plotly.
if (create.plotly) {
  cat("Writing interactive plot to pcvsgeo.html.\n")
  outlier         <- factor(outlier)
  levels(outlier) <- c("no","yes")
  out <- ggplot(data.frame(c1        = geodist,
                           c2        = PCdist,
                           countries = pwlabels,
                           outlier   = factor(outlier)),
                aes(x = c1,y = c2,countries = countries,col = outlier)) +
    geom_point() +
    theme_minimal() +
    theme(panel.grid.major = element_blank(),
          panel.grid.minor = element_blank()) +
    geom_abline(intercept = lPC$coefficients[1],slope = lPC$coefficients[2]) +
    geom_abline(intercept = lPC$coefficients[1] + quantile(residsPC,1 - alpha),
                slope=lPC$coefficients[2],linetype = "dashed") +
    geom_abline(intercept = lPC$coefficients[1] - quantile(residsPC,1 - alpha),
                slope = lPC$coefficients[2],linetype = "dashed") +
    scale_color_manual(values = c("royalblue","magenta")) +
    xlab("Geographic distance (km)") +
    ylab("Euclidean distance in PC1-PC2 space")
  saveWidget(hide_legend(ggplotly(out,tooltip = "countries")),
             "pcvsgeo.html",selfcontained = FALSE)
}
